{"ast":null,"code":"var _jsxFileName = \"D:\\\\CODEGYM\\\\CODEGYM\\\\REACTJS\\\\duonghuuthanh\\\\demoapp\\\\src\\\\DemoReducer.js\",\n    _s = $RefreshSig$();\n\nimport { useReducer } from \"react\";\nimport myReducer from \"./reducers/MyReducer\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst DemoReducer = () => {\n  _s();\n\n  /**\r\n   * (alias) useReducer<(state: any, action: any) => any>\r\n   * (reducer: (state: any, action: any) => any, initializerArg: any, initializer?: undefined):\r\n   *  [any, React.DispatchWithoutAction] (+4 overloads)\r\n      import useReducer\r\n      An alternative to useState.\r\n        useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.\r\n   */\n  const [state, dispatch] = useReducer(myReducer, {\n    \"counter\": 0\n  });\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: [\"Counter: ...\", state.counter]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => dispatch({\n        \"type\": \"desc\"\n      }),\n      children: \"-\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: () => dispatch({\n        \"type\": \"inc\"\n      }),\n      children: \"+\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true);\n};\n\n_s(DemoReducer, \"3Yjr1kuoQAkLi5etFL9yd3zD5K8=\");\n\n_c = DemoReducer;\nexport default DemoReducer;\n\nvar _c;\n\n$RefreshReg$(_c, \"DemoReducer\");","map":{"version":3,"names":["useReducer","myReducer","DemoReducer","state","dispatch","counter"],"sources":["D:/CODEGYM/CODEGYM/REACTJS/duonghuuthanh/demoapp/src/DemoReducer.js"],"sourcesContent":["import { useReducer } from \"react\"\r\nimport myReducer from \"./reducers/MyReducer\"\r\n\r\nconst DemoReducer = ()=>{\r\n    /**\r\n     * (alias) useReducer<(state: any, action: any) => any>\r\n     * (reducer: (state: any, action: any) => any, initializerArg: any, initializer?: undefined):\r\n     *  [any, React.DispatchWithoutAction] (+4 overloads)\r\n        import useReducer\r\n        An alternative to useState.\r\n\r\n        useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks.\r\n     */\r\n    const [state, dispatch] = useReducer(myReducer, {\r\n        \"counter\": 0\r\n    })\r\n    return (\r\n        <>\r\n            <h1>Counter: ...{state.counter}</h1>\r\n            <button onClick={()=> dispatch({\"type\": \"desc\"})}>-</button>\r\n            <button onClick={()=> dispatch({\"type\": \"inc\"})}>+</button>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default DemoReducer"],"mappings":";;;AAAA,SAASA,UAAT,QAA2B,OAA3B;AACA,OAAOC,SAAP,MAAsB,sBAAtB;;;;AAEA,MAAMC,WAAW,GAAG,MAAI;EAAA;;EACpB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EAEI,MAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,UAAU,CAACC,SAAD,EAAY;IAC5C,WAAW;EADiC,CAAZ,CAApC;EAGA,oBACI;IAAA,wBACI;MAAA,2BAAiBE,KAAK,CAACE,OAAvB;IAAA;MAAA;MAAA;MAAA;IAAA,QADJ,eAEI;MAAQ,OAAO,EAAE,MAAKD,QAAQ,CAAC;QAAC,QAAQ;MAAT,CAAD,CAA9B;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAFJ,eAGI;MAAQ,OAAO,EAAE,MAAKA,QAAQ,CAAC;QAAC,QAAQ;MAAT,CAAD,CAA9B;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QAHJ;EAAA,gBADJ;AAOH,CApBD;;GAAMF,W;;KAAAA,W;AAsBN,eAAeA,WAAf"},"metadata":{},"sourceType":"module"}