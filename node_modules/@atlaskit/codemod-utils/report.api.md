## API Report File for "@atlaskit/codemod-utils".

> Do not edit this file. This report is auto-generated by [API Extractor](https://api-extractor.com/).

[Learn more about API reports](https://hello.atlassian.net/wiki/spaces/UR/pages/1825484529/Package+API+Reports)

```ts
import { API } from 'jscodeshift';
import { ASTPath } from 'jscodeshift';
import { CallExpression } from 'jscodeshift';
import { Collection } from 'jscodeshift/src/Collection';
import core from 'jscodeshift';
import { FileInfo } from 'jscodeshift';
import { ImportDeclaration } from 'jscodeshift';
import { ImportDefaultSpecifier } from 'jscodeshift';
import { ImportSpecifier } from 'jscodeshift';
import { JSXAttribute } from 'jscodeshift';
import { JSXElement } from 'jscodeshift';
import { Options } from 'jscodeshift';
import { Program } from 'jscodeshift';
import { VariableDeclaration } from 'jscodeshift';
import { VariableDeclarator } from 'jscodeshift';

export declare function addCommentBefore(
  j: core.JSCodeshift,
  target:
    | Collection<Program>
    | Collection<ImportDeclaration>
    | Collection<JSXElement>
    | Collection<JSXAttribute>
    | Collection<CallExpression>
    | Collection<VariableDeclarator>,
  message: string,
  commentType?: 'block' | 'line',
  messagePrefix?: string,
): void;

export declare const addCommentToStartOfFile: ({
  j,
  base,
  message,
}: {
  j: core.JSCodeshift;
  base: Collection<Node>;
  message: string;
}) => void;

export declare const addDynamicImport: (
  j: core.JSCodeshift,
  target: Collection<VariableDeclaration>,
  name: string,
  packageEndpoint: string,
) => void;

export declare function addToImport(
  j: core.JSCodeshift,
  base: Collection<any>,
  importSpecifier: ImportSpecifier | ImportDefaultSpecifier,
  packageName: string,
): void;

export declare const callExpressionArgMatchesString: (
  arg: CallExpression['arguments'][number],
  str: string,
) => boolean;

export declare const changeImportEntryPoint: (
  oldPackageName: string,
  importToConvert: string,
  newPackageName: string,
  shouldBeTypeImport?: boolean | undefined,
) => (j: core.JSCodeshift, root: Collection<Node>) => void;

export declare const createConvertFuncFor: (
  component: string,
  from: string,
  to: string,
  predicate?: ((value: any) => boolean) | undefined,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const createRemoveFuncAddCommentFor: (
  component: string,
  prop: string,
  comment?: string | undefined,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const createRemoveFuncFor: (
  component: string,
  importName: string,
  prop: string,
  predicate?: (j: core.JSCodeshift, element: ASTPath<any>) => boolean,
  comment?: string | undefined,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const createRenameFuncFor: (
  component: string,
  from: string,
  to: string,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const createRenameImportFor: (
  component: string,
  from: string,
  to: string,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const createRenameJSXFunc: (
  packagePath: string,
  from: string,
  to: string,
  fallback?: string | undefined,
) => (j: core.JSCodeshift, source: any) => void;

export declare const createTransformer: (
  migrates: ((j: core.JSCodeshift, source: Collection<Node>) => void)[],
  shouldApplyTransform?:
    | ((j: core.JSCodeshift, source: Collection<Node>) => boolean)
    | undefined,
) => (fileInfo: FileInfo, { jscodeshift: j }: API, options: Options) => string;

export declare const doesIdentifierExist: (
  j: core.JSCodeshift,
  base: Collection<any>,
  name: string,
) => boolean;

export declare const elevateComponentToNewEntryPoint: (
  pkg: string,
  toPkg: string,
  innerElementName: string,
) => (j: core.JSCodeshift, root: any) => void;

export declare const flattenCertainChildPropsAsProp: (
  component: string,
  propName: string,
  childProps: string[],
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const getDefaultSpecifier: (
  j: core.JSCodeshift,
  source: Collection<Node>,
  specifier: string,
) => string | null;

export declare const getDynamicImportName: (
  j: core.JSCodeshift,
  source: Collection<any>,
  importPath: string,
) => string | null;

export declare const getJSXAttributesByName: (
  j: core.JSCodeshift,
  element: ASTPath<any>,
  attributeName: string,
) => Collection<JSXAttribute>;

export declare function getNamedSpecifier(
  j: core.JSCodeshift,
  source: Collection<Node>,
  specifier: string,
  importName: string,
): string | null;

export declare function getSafeImportName({
  j,
  base,
  currentDefaultSpecifierName,
  desiredName,
  fallbackName,
}: {
  j: core.JSCodeshift;
  base: Collection<any>;
  currentDefaultSpecifierName: string | null;
  desiredName: string;
  fallbackName: string;
}): string;

export declare const hasImportDeclaration: (
  j: core.JSCodeshift,
  source: Collection<Node>,
  importPath: string,
) => boolean;

export declare const hasImportDeclarationFromAnyPackageEntrypoint: (
  j: core.JSCodeshift,
  source: Collection<Node>,
  packageName: string,
) => boolean;

export declare const hasJSXAttributesByName: (
  j: core.JSCodeshift,
  element: ASTPath<any>,
  attributeName: string,
) => boolean;

export declare function removeImport(
  j: core.JSCodeshift,
  base: Collection<any>,
  packageName: string,
): void;

export declare const renameNamedImportWithAliasName: (
  component: string,
  from: string,
  to: string,
) => (j: core.JSCodeshift, source: Collection<Node>) => void;

export declare const replaceImportStatementFor: (
  pkg: string,
  convertMap: any,
) => (j: core.JSCodeshift, root: Collection<Node>) => void;

export declare const testMethodVariantEach: (
  path: ASTPath<CallExpression>,
  testMethods: Set<string>,
) => boolean;

export declare function tryCreateImport(
  j: core.JSCodeshift,
  base: Collection<any>,
  relativeToPackage: string,
  packageName: string,
  shouldBeTypeImport?: boolean,
): void;

export {};
```
